# Τι μέρα είναι;
Μπορείτε να διαβάσετε το πρόβλημα και να κάνετε submit [εδώ](https://www.hackerrank.com/contests/easy-arrays/challenges/challenge-153) (Σημείωση: Αν η σελίδα δεν ανοίγει, δοκιμάστε να κάνετε sign in).

## Βήμα 1: Το input
Ένα βήμα που ίσως να μας μπερδεύει είναι το input, αφού οι αριθμοί χωρίζονται με `/` χωρίς spaces. Βλέπουμε ότι, πράγματι, το `cin>>d>>n>>y;` δεν λειτουργεί. 

Όμως, αν κάνουμε `cout<<d;` αφού διαβάσουμε το input όπως πριν, η τιμή που τυπώνεται είναι σωστή. Έτσι, βλέπουμε ότι όταν ένας αριθμός ακολουθείται από άλλους χαρακτήρες μπορούμε πάλι να τον διαβάσουμε. Το πρόβλημα είναι ότι μετά προσπαθούμε να διαβάσουμε ακόμα έναν αριθμό, όμως εκεί βρίσκεται το `/`.

Η ευκολότερη λύση είναι απλή: αφού διαβάσουμε κάθε αριθμό που ακολουθείται από `/`, θα διαβάσουμε και ενα character που θα φυλάξουμε σε μια μεταβλητή που δεν θα χρησιμοποιήσουμε:
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

int main(){
    ll d, m, y;
    char c;
    cin>>d>>c>>m>>c>>y;
    
    cout<<d<<" "<<m<<" "<<y<<endl;  // Για να ελέγξουμε ότι οι τιμές είναι σωστές
}
```

## Βήμα 2: Οι μέρες που έχουν περάσει
Για να βρούμε ποια μέρα της εβδομάδας είναι η μέρα που μας δίνεται, πρέπει να βρούμε πόσες μέρες έχουν περάσει από την 1/1/1902. Έτσι, το χωρίζουμε σε βήματα:
- Μέρες από την αρχή του μήνα μέχρι την ημερομηνία που δίνεται
- Μέρες από την αρχή του χρόνου μέχρι την αρχή του μήνα
- Μέρες από την αρχή του 1902 μέχρι την αρχή του χρόνου

Είναι εύκολο να δούμε ότι από την αρχή του μήνα έχουν περάσει $d-1$ μέρες ($-1$ επειδή από την πρώτη μέρα έχουν περάσει 0 μέρες). Επίσης έχουν περάσει $y-1902$ χρόνια και, αν αγνοήσουμε τα δίσεκτα έτη, τα οποία θα βρούμε αργότερα, το καθένα έχει 365 μέρες, άρα συνολικά $365\cdot(y-1902)$ μέρες.

## Βήμα 3: Οι μέρες από την αρχή του χρόνου
Το να βρούμε πόσες μέρες έχουν περάσει από την αρχή του χρόνου είναι πιο δύσκολο, αφού οι μήνες δεν έχουν σταθερό αριθμό ημερών. Μπορούμε όμως να έχουμε ένα έτοιμο array με τον αριθμό ημερών του κάθε μήνα και να προσθέτουμε αυτή την τιμή στην απάντησή μας για κάθε μήνα πριν τον μήνα του input:
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

int main(){
    ...
    
    ll x[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
    for(ll i=1; i<m; i++){
        ans+=x[i];
    }

    ...
}
```

## Βήμα 4: Δίσεκτα έτη

### Οι προηγούμενοι χρόνοι
Τώρα πρέπει να υπολογίσουμε ακόμα κάτι: πόσα δίσεκτα έτη έχουν περάσει από το 1902 μέχρι τον χρόνο του input. Όπως μπορεί να θυμάστε από [ένα προηγούμενο πρόβλημα](https://www.hackerrank.com/contests/control-structures/challenges/challenge-141):
>  Ένα έτος είναι δίσεκτο αν διαιρείται ακριβώς με το 4, εκτός αν διαιρείται ακριβώς και με το 100 οπότε και δεν είναι δίσεκτο. Ωστόσο, αν διαιρείται με το 400 τότε το έτος είναι δίσεκτο. Για παράδειγμα, το 2012 είναι δίσεκτο γιατί 2012/4 = 503, όπως και το 1200 είναι δίσεκτο γιατί 1200/400 = 3. Το 2100 δεν είναι δίσεκτο γιατί 2100/100 = 21.

Ο πιο απλός τρόπος είναι να περάσουμε από κάθε χρονιά μέχρι την προηγούμενη από αυτή του input και να προσθέτουμε μια μέρα κάθε φορά που βρίσκουμε ένα δίσεκτο έτος:
> [!TIP]
> Όταν έχουμε κανόνες με εξαιρέσεις, όπως εδώ, ξεκινούμε από τους κανόνες που δεν έχουν εξαιρέσεις (π.χ. εδώ, αν ο χρόνος διαιρείται με το 400 είναι σίγουρα δίσεκτος). Ύστερα, ελέγχουμε τους κανόνες των οποίων τις εξαιρέσεις έχουμε ήδη ελέγξει (π.χ. εδώ, αν ο χρόνος διαιρείται με το 100 δεν είναι δίσεκτος, εκτός αν διαιρείται με το 400, στην οποία περίπτωση θα το έχουμε βρει ήδη, αφού θα έχουμε ελέγξει αν διαιρείται με το 400 πιο πριν).
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

int main(){
    ...
    
    for(ll i=1902; i<y; i++){
        bool l;
        if(i%400==0) l=true;
        else if(i%100==0) l=false;
        else if(i%4==0) l=true;
        else l=false;
        
        if(l){
            ans++;
        }
    }

    ...
}
```

### Αυτός ο χρόνος
Μένει να ελέγξουμε αν το έτος του input είναι δίσεκτο, και να προσθέσουμε μια μέρα στον Φεβρουάριο αν είναι (Αυτό πρέπει να γίνει πριν υπολογίσουμε τις μέρες από την αρχή του χρόνου μέχρι την αρχή του μήνα). Μπορούμε το κάνουμε με τον ίδιο τρόπο που ελέγχαμε κάθε χρόνο πριν.

## Βήμα 5: Η μέρα της εβδομάδας
Καταρχάς είναι εύκολο να δούμε ότι αν ο αριθμός των ημερών που έχουν περάσει είναι πολλαπλάσιο του 7, η μέρα που πρέπει να βρούμε είναι η ίδια με την 1/1/1902, άρα Τετάρτη. Αντίστοιχα, αν το υπόλοιπο έιναι 1, η προηγούμενη μέρα ήταν πολλαπλάσιο του 7, άρα αυτή η μέρα είναι Πέμπτη, αν το υπόλοιπο είναι 3 είναι Παρασκευή κλπ. Άρα έχουμε:
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

int main(){
    ...
    
    if(ans%7==0){
        cout<<"Wednesday"<<endl;
    }
    else if(ans%7==1){
        cout<<"Thursday"<<endl;
    }
    else if(ans%7==2){
        cout<<"Friday"<<endl;
    }
    else if(ans%7==3){
        cout<<"Saturday"<<endl;
    }
    else if(ans%7==4){
        cout<<"Sunday"<<endl;
    }
    else if(ans%7==5){
        cout<<"Monday"<<endl;
    }
    else if(ans%7==6){
        cout<<"Tuesday"<<endl;
    }
}
```

### Λύση με strings
> [!NOTE]
> Θα μάθουμε τα strings σε ένα επόμενο μάθημα

Για να βρούμε σε ποιά μέρα αντιστοιχεί το υπόλοιπο, μπορούμε επίσης να έχουμε ένα έτοιμο array από strings όπου η θέση $a_i$ να περιέχει την μέρα της εβδοάδας αν το υπόλοιπο είναι $i$.
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

int main(){
    ...
    
    string a[7]={"Wednesday","Thursday","Friday","Saturday","Sunday","Monday","Tuesday"};
    cout<<a[ans%7]<<endl;
}
```

## Ο κώδικας
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

int main(){
    // Input
    ll d, m, y;
    char c;
    cin>>d>>c>>m>>c>>y;
    
    // Μέρες από το 1902 μέχρι την αρχή του χρόνου και από την αρχή του μήνα μέχρι την ημερομηνία που δίνεται
    ll ans=d-1+365*(y-1902);
    
    // Μέρες από την αρχή του χρόνου μέχρι την αρχή του μήνα
    ll x[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
    if(y%400==0) x[2]=29; // Έλεγχος για δίσεκτο
    else if(y%100==0) x[2]=28;
    else if(y%4==0) x[2]=29;
    else x[2]=28;
    for(ll i=1; i<m; i++){
        ans+=x[i];
    }
    
    // Δίσεκτα έτη
    for(ll i=1902; i<y; i++){
        bool l;
        if(i%400==0) l=true;
        else if(i%100==0) l=false;
        else if(i%4==0) l=true;
        else l=false;
        
        if(l){
            ans++;
        }
    }
    
    // Output
    if(ans%7==0){
        cout<<"Wednesday"<<endl;
    }
    else if(ans%7==1){
        cout<<"Thursday"<<endl;
    }
    else if(ans%7==2){
        cout<<"Friday"<<endl;
    }
    else if(ans%7==3){
        cout<<"Saturday"<<endl;
    }
    else if(ans%7==4){
        cout<<"Sunday"<<endl;
    }
    else if(ans%7==5){
        cout<<"Monday"<<endl;
    }
    else if(ans%7==6){
        cout<<"Tuesday"<<endl;
    }
}
```

## Τι κρατάμε από αυτό το πρόβλημα
Αυτό το πρόβλημα ήταν ένας συνδυασμός όσων μάθαμε μέχρι τώρα (μεταβλητές, control structures, loops και arrays). Είναι σημαντικό να μπορούμε να λύσουμε προβλήματα όπου πρέπει να υπολογίσουμε κάτι συνδυάζοντας τις γνώσεις μας για διαφορετικά πράγματα. 

Κάποια πράγματα που είδαμε για πρώτη φορά:
- **Input με χαρακτήρες** - Όταν πρέπει να διαβάσουμε αριθμούς που χωρίζονται με χαρακτήρες, μπορούμε να το κάνουμε κανονικά, αρκεί να διαβάσουμε τους χαρακτήρες αυτούς όπου υπάρχουν και να τους φυλάξουμε σε μια άλλη μεταβλητή.
- **Array με αντίστοιχες τιμές** - Για να φυλάξουμε εύκολα τις αντίστοιχες τιμές κάποιων αριθμών (π.χ. των αριθμό ημερών που έχει κάθε μήνας) μπορούμε να χρησιμοποιήσουμε ένα array που να δημιουργήσουμε μόνοι μας.
